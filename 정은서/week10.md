# [정은서] 2025 GDG Spring Advanced Study - 10주차
# 토비의 스프링 3.1(vol1) - 9.3장 애플리케이션 아키텍처

### 9.3 애플리케이션 아키텍처

아키텍처: 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것 

9.3.1 계층형 아키텍처

- 관심, 책임, 성격, 변하는 이유와 방식이 서로 다른 것들을 분리할 수 있었음
- 성격이 다른 것은 아키텍처 레벨에서 분리해주는 것이 좋다
- 이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 계층형 아키텍처라 함
- 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고 함
    - 데이터 엑세스 계층
        - 백엔드 DB나 레거시 시스템과 연동하는 인터페이스 역할
        - 추상화 수직 계층 구조
    - 서비스 계층
        - 비즈니스 로직
        - 서비스 계층이 필요에 따라 기반 서비스 계층의 API를 호출
        - 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 됨
        - 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어야함
        - 또는 AOP를 통해서 서비스 계층의 코드를 침법하지 않고 부가기능을 추가하는 방법을 활용
    - 프레젠테이션 계층
        - 웹 기반의 UI를 만들어내고 그 흐름을 관리
        - 매우 다양한 기술과 프레임워크의 조합을 가질 수 있음
        - 클라이언트까지 범위 확장 가능
        - 스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공
- 각 계층은 자신의 계층에만 충실해야 함

9.3.2 애플리케이션 정보 아키텍처

엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템

엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우로 구분

- **데이터 중심 아키텍처**
    - 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조
    - 비즈니스 로직이 DB 내부의 저장 프로시저나 SQL에 담겨 있는 경우가 많음
    - 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분
    - 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있음 → 변화에 매우 취약
    - 개발이 쉬움 - 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시키는 것
    - 거대한 서비스 계층 방식
        - DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법
        - DB에 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다
            - 서비스 로직의 대부분이 서비스 계층 코드에 집중
            - 자바 언어의 장점을 활용해 로직 구현, 테스트 용이
        - DAO가 거대 서비스 계층 방식에 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 됨 → DAO, SQL은 상대적으로 단순해지고, 그중 일부는 여러 서비스 계층 코드에서 재사용 가능
    - 계층 사이의 결합도가 높은 편이고 응집도는 떨어짐
    - 장기적으로 코드를 관리하고 발전시키기 어려움
    

9.3.3 **오브젝트 중심 아키텍처**

- 데이터 중심 아키텍처와 다르게 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용함
- 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용
- 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것

예시) 데이터와 오브젝트

두 가지 엔티티 - 카테고리와 상품(1:N)

- category

| CategoryId | int | PK |
| --- | --- | --- |
| Description | varchar(100) |  |
- Product

| ProductId | int | PK |
| --- | --- | --- |
| Name | varchar(100) |  |
| Price | int |  |
| CategoryId | int | FK |

```sql
select c.categoryid, c.description, p.productid, p.name, p.price from product p
join category c on p.categoryid = c.categoryid
```

가져온 정보를 웹 페이지 내에서 수정해서 DB에 다시 반영해야 한다면?

- 데이터 중심 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 됨
- 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다 → 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다

```java
public class Category {
	int categoryId;
	String description;
	Set<Product> products; // 0~N개의 Product를 참조하는 컬렉션
}

public class Product {
	int productId;
	String name;
	int price;
	Category category; // 1개의 Category를 가리키는 레퍼런스를 직접 가짐 
}
```

- Category 오브젝트를 가리키는 레퍼런스 변수를 가짐으로써 Product class 에는 Product 테이블처럼 categoryid라는 외래키가 없다
- 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있다
- 가져온 도메인 오브젝트에 담긴 정보를 활용서 비즈니스 로직을  처리하면 됨
- 도메인 오브젝트를 사용하는 코드(카테고리에 담긴 모든 상품의 가격의 합 계산)

```java
public int calcTotalProductPrice(Category cate) {
	int sum = 0;
	for (product prd : cate.getProducts()) { // Category에 포함된 모든 Product를 간단히 가져올 수 있음 
		sum += prd.getPrice();
	}
	return sum
}
```

- 단점
    - 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 필드뿐이라면 DAO에서 도메인 오브젝트의 모든 필드 정보를 채워서 전달하는 것은 낭비일 수도 있음
- 지연된 로딩 사용, 오브젝트/RDB 매핑 기술 사용
- 빈약한 오브젝트: 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않은 오브젝트
- 풍성한 도메인 오브젝트(영리한 도메인 오브젝트): 특정 도메인 오브젝트와 깊은 관계가 있는 비즈니스 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것

```java
public class Category {
    ...
    List<Product> products;

    public int calcTotalOfProductPrice() { 
        // Category를 따로 파라미터로 받을 필요가 없다. 자신이 가진 정보를 직접 사용하면 되기 때문이다.
        int sum = 0;
        for(Product prd : this.products()) { 
            // 오브젝트가 가진 내부 정보를 활용해서 필요한 계산이나 로직을 수행하면 된다.
            sum += prd.getPrice();
        }
        return sum;
    }
}
```

→ 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높음 

- 다른 서비스 오브젝트의 로직을 사용하는 경우

```java
public class InventoryService {
    private CategoryService categoryService;

    public void setCategoryService(CategoryService categoryService) { 
        // → 다른 서비스 오브젝트에 담긴 로직을 사용하기 위해 DI를 해줘야 한다.
        this.categoryService = categoryService;
    }

    public void complexInventoryAnalysis() {
        ...
        int total = this.categoryService.calcTotalOfProductPrice(category);
        ... 
        // ↓ 계산 로직에서 사용될 정보를 가진 Category를 파라미터로 전달해야 한다.
    }
}
```

- 자체 로직을 가진 Category를 사용하는 코드

```java
public class InventoryService {
    public void complexInventoryAnalysis() {
        ...
        int total = category.calcTotalOfProductPrice(); 
        // → 서비스 계층의 메소드를 사용하는 코드보다 훨씬 간결하고 직관적이라서 
        //   이해하기도 쉽다. 무엇보다도 객체지향적이다.
        ...
    }
}
```

- 도메인 계층 방식
    - 도메인 오브젝트에 담을 수 있는 비즈니스 로직은 데이터 엑세스 계층에서 가져온 내부 데이터를 분석하거나, 조건에 따라 오브젝트 정보를 변경, 생성 하는 정도에 그칠 수밖에 없음
    - 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식 → 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 엑세스 계층 사이에 존재
    1. 도메인에 종속적인 비스니스 로직의 처리는 서비스 계층이 아닌 도메인 계층의 오브젝트 안에서 진행 
    2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있음 
    - 고려할 사항 - 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정
        1. 여전히 모든 계층에서 사용
        2. 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 함 
            - 도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줌 → DTO
    - 매우 복잡하고 변경이 잦은 도메인을 가졌을 때 사용하면 좋음

9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

- 계층형 아키텍처
    - 3계층 구조
        - 프레젠테이션 계층은 SpringMVC를 이용하고 서비스 계층은 POJO로 구현하면서 트랜잭션 AOP를 적용하고 데이터 액세스 계층은 JPA, 하이버네이트, JDO 등을 활용
    - 3계층에서 두 개의 계층이 통합돼서 하나의 오브젝트에 담기는 경우
- 정보 전송 아키텍처
    - 오브젝트 중심 아키텍처의 도메인 오브젝트 방식
- 상태 관리와 빈 스코프
    - 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태정보가 있음
    - 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업 정보는 유지돼야 한다.
    - 빈 스코프를 잘 활용하면 스프링이 관리하는 빈이면서 사용자 별로 또는 단위 작업별로 독립적으로 생성되고 유지되는 오브젝트를 만들어 상태를 저장하고 이를 DI해서 사용할 수 있음
- 서드파티 프레임워크, 라이브러리 적용
    1. 프레임워크가 라이브러리의 핵심 클래스를 빈으로 등록할 수 있도록 지원
    2. 스프링의 서비스 추상화가 적용됨
    3. 스프링이 지지하는 프로그래밍 모델을 적용함
    4. 템플릿/콜백이 지원됨